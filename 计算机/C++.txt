1.对象生命周期结束，被销毁时；
2.delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时；
3.对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用
4.构造函数是先调用基类的构造函数，在调用派生类的构造函数
5 C和C++不能重载的运算符sizeof 运算符  :: 作用域运算符 ?:条件运算符 . 直接成员运算符  *指针运算符
6 static的作用定义静态局部变量，定义静态外部全局变量，声明静态外部函数
7 浅拷贝和深拷贝和赋值操作，A a,A b,a=b;赋值操作，A a; A b=a;浅拷贝操作调用拷贝构造函数； A a；A b;a=b；深拷贝调用重载的复制运算符
8 无符号数和有符号数相加，都转换为无符号数
9 虚继承时，类不会共享虚基类指针，也不会共享虚表指针
10 0开头代表8进制数，0x开头代表16进制数
11 转义序列有\n \t \a \v \b \" \\ \? \' \r \f 引用必须在定义时被初始化，只能引用到对象,引用不是对象,const对象必须被初始化，常量表达式的值在编译就得到计算 const int &i=0;合法 
12 函数fopen r+以可读写方式打开文件，该文件必须存在（只是覆盖不清空） w打开只写文件（原文件内容清空），若不存在会创建，w+打开可读写文件，若文件不存在则创建 a以附加方式打开只写文件，不存在则创建（原文件保留），a+ 以附加方式打开可读写文件，没有则创建
13 Struct和Class的唯一区别在于默认的访问权限，Struct为Public而Class为Private
14 只有通过指针和引用调用虚函数时，才会在运行期解析该调用，否则都是在编译期
15 memcpy函数实现
16 浅拷贝相当于生成对象的引用，深拷贝全新开辟空间，重新生成变量
17 函数指针的一般定义形式为 数据类型（*指针变量名）（参数表）
18 
