一、 01硬币找零问题（01背包）
给定不同面额的硬币 coins 和总金额 m。每个硬币最多选择一次。计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
状态表示
f[i][j] 表示只看前 i 个物品，总价值是 j 的情况下的最小硬币数目。
状态转移
f[i, j] = min(f[i-1, j], f[i-1, j-ci] + 1) 分别对应了不拿和拿第 i 个硬币两种情况。
因为 f[i, j] 只和上一层的两个状态有关，所以可以将状态优化为一维数组。
f[j] = min(f[j], f[j-ci] + 1)，
因为 j-ci < j，所以如果从小到大枚举金额的话，j-ci 已经变成了第 i 层的状态。
所以这一步可以从大到小枚举金额，确保计算到 j 时，j-ci 还是上一层的状态。边界情况
f[0] = 0 表示凑出金额为0的最小个数是0个。
二、完全硬币找零问题（完全背包）
给定不同面额的硬币 coins 和总金额 m。每个硬币可以选择无数次。计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
状态表示f[i][j] 为考虑前 i 种硬币，凑出金额为 j 的最少数目。
状态转移考第 i 种硬币，我们可以不拿，或者拿 1...k 个，直到把金额拿爆。
f[i][j] = min(f[i-1]f[j], f[i-1][j-c]+1, f[i-1][j-2*c]+2, ..., f[i-1][j-k*c]+k)
f[0] = 0 表示金额为0时，最小硬币凑法为0
三、多重硬币找零问题（多重背包）
给定不同面额的硬币 coins 和总金额 m。每个硬币选择的次数有限制为 s。计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
状态表示这里和完全硬币问题的的初始状态表态表示很相似。考第i种硬币，我们可以不拿，或者拿1...k个，直到拿到个数的限制。
f[i][j] = min(f[i-1]f[j], f[i-1][j-c]+1, f[i-1][j-2*c]+2, ..., f[i-1][j-k*c]+k-1)所以在01问题的代码的基础上添加一层枚举硬币个数的循环即可这里可以使用二进制优化，转化为01背包问题求解。这里不扩展了。
四、博弈问题动态规划
dp[i][j].fir 表示，对于 piles[i...j] 这部分石头堆，先手能获得的最高分数。
dp[i][j].sec 表示，对于 piles[i...j] 这部分石头堆，后手能获得的最高分数。
举例理解一下，假设 piles = [3, 9, 1, 2]，索引从 0 开始
dp[0][1].fir = 9 意味着：面对石头堆 [3, 9]，先手最终能够获得 9 分。
dp[1][3].sec = 2 意味着：面对石头堆 [9, 1, 2]，后手最终能够获得 2 分。
dp[i][j].fir = max(piles[i] + dp[i+1][j].sec, piles[j] + dp[i][j-1].sec)

dp[i][j].fir = max(选择最左边的石头堆 , 选择最右边的石头堆)
# 解释：我作为先手，面对 piles[i...j] 时，有两种选择：
# 要么我选择最左边的那一堆石头，然后面对 piles[i+1...j]
# 但是此时轮到对方，相当于我变成了后手；
# 要么我选择最右边的那一堆石头，然后面对 piles[i...j-1]
# 但是此时轮到对方，相当于我变成了后手。
if 先手选择左边: dp[i][j].sec = dp[i+1][j].fir  if 先手选择右边:dp[i][j].sec = dp[i][j-1].fir
# 解释：我作为后手，要等先手先选择，有两种情况：
# 如果先手选择了最左边那堆，给我剩下了 piles[i+1...j]
# 此时轮到我，我变成了先手；
# 如果先手选择了最右边那堆，给我剩下了 piles[i...j-1]
# 此时轮到我，我变成了先手。



