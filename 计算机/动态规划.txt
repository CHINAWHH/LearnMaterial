一、 01硬币找零问题（01背包）
给定不同面额的硬币 coins 和总金额 m。每个硬币最多选择一次。计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
状态表示
f[i][j] 表示只看前 i 个物品，总价值是 j 的情况下的最小硬币数目。
状态转移
f[i, j] = min(f[i-1, j], f[i-1, j-ci] + 1) 分别对应了不拿和拿第 i 个硬币两种情况。
因为 f[i, j] 只和上一层的两个状态有关，所以可以将状态优化为一维数组。
f[j] = min(f[j], f[j-ci] + 1)，
因为 j-ci < j，所以如果从小到大枚举金额的话，j-ci 已经变成了第 i 层的状态。
所以这一步可以从大到小枚举金额，确保计算到 j 时，j-ci 还是上一层的状态。边界情况
f[0] = 0 表示凑出金额为0的最小个数是0个。
二、完全硬币找零问题（完全背包）
给定不同面额的硬币 coins 和总金额 m。每个硬币可以选择无数次。计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
状态表示f[i][j] 为考虑前 i 种硬币，凑出金额为 j 的最少数目。
状态转移考第 i 种硬币，我们可以不拿，或者拿 1...k 个，直到把金额拿爆。
f[i][j] = min(f[i-1]f[j], f[i-1][j-c]+1, f[i-1][j-2*c]+2, ..., f[i-1][j-k*c]+k)
f[0] = 0 表示金额为0时，最小硬币凑法为0
三、多重硬币找零问题（多重背包）
给定不同面额的硬币 coins 和总金额 m。每个硬币选择的次数有限制为 s。计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
状态表示这里和完全硬币问题的的初始状态表态表示很相似。考第i种硬币，我们可以不拿，或者拿1...k个，直到拿到个数的限制。
f[i][j] = min(f[i-1]f[j], f[i-1][j-c]+1, f[i-1][j-2*c]+2, ..., f[i-1][j-k*c]+k-1)所以在01问题的代码的基础上添加一层枚举硬币个数的循环即可这里可以使用二进制优化，转化为01背包问题求解。这里不扩展了。
四、二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；
对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为a[i]和b[i]。两种代价可付出的最大值（两种背包容量）分别为V和U。物品的价值为c[i]。
算法费用加了一维，只需状态也加一维即可。设f[i][v][u]表示前i件物品付出两种代价分别为v和u时可获得的最大价值。
状态转移方程就是：dp[i][v][u]=max{dp[i-1][v][u],dp[i-1][v-a[i]][u-b[i]]+cost[i]}。如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量v和u采用逆序的循环，当物品有如完全背包问题时采用顺序的循环。当物品有如多重背包问题时拆分物品。
五、博弈问题动态规划
dp[i][j].fir 表示，对于 piles[i...j] 这部分石头堆，先手能获得的最高分数。
dp[i][j].sec 表示，对于 piles[i...j] 这部分石头堆，后手能获得的最高分数。
举例理解一下，假设 piles = [3, 9, 1, 2]，索引从 0 开始
dp[0][1].fir = 9 意味着：面对石头堆 [3, 9]，先手最终能够获得 9 分。
dp[1][3].sec = 2 意味着：面对石头堆 [9, 1, 2]，后手最终能够获得 2 分。
dp[i][j].fir = max(piles[i] + dp[i+1][j].sec, piles[j] + dp[i][j-1].sec)

dp[i][j].fir = max(选择最左边的石头堆 , 选择最右边的石头堆)
# 解释：我作为先手，面对 piles[i...j] 时，有两种选择：
# 要么我选择最左边的那一堆石头，然后面对 piles[i+1...j]
# 但是此时轮到对方，相当于我变成了后手；
# 要么我选择最右边的那一堆石头，然后面对 piles[i...j-1]
# 但是此时轮到对方，相当于我变成了后手。
if 先手选择左边: dp[i][j].sec = dp[i+1][j].fir  if 先手选择右边:dp[i][j].sec = dp[i][j-1].fir
# 解释：我作为后手，要等先手先选择，有两种情况：
# 如果先手选择了最左边那堆，给我剩下了 piles[i+1...j]
# 此时轮到我，我变成了先手；
# 如果先手选择了最右边那堆，给我剩下了 piles[i...j-1]
# 此时轮到我，我变成了先手。
六 股票交易问题、
dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易
我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
              max(   选择 rest  ,           选择 sell      )
解释：今天我没有持有股票，有两种可能：
要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；
要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
              max(   选择 rest  ,           选择 buy         )
解释：今天我持有着股票，有两种可能：
要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；
要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了
选择在买的时候减少交易次数
p[-1][k][0] = 0
解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。
dp[-1][k][1] = INT_MIN
解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。
dp[i][0][0] = 0
解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。
dp[i][0][1] = INT_MIN
解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。




