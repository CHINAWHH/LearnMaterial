一、 01硬币找零问题（01背包）
给定不同面额的硬币 coins 和总金额 m。每个硬币最多选择一次。计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
状态表示
f[i][j] 表示只看前 i 个物品，总价值是 j 的情况下的最小硬币数目。
状态转移
f[i, j] = min(f[i-1, j], f[i-1, j-ci] + 1) 分别对应了不拿和拿第 i 个硬币两种情况。
因为 f[i, j] 只和上一层的两个状态有关，所以可以将状态优化为一维数组。
f[j] = min(f[j], f[j-ci] + 1)，
因为 j-ci < j，所以如果从小到大枚举金额的话，j-ci 已经变成了第 i 层的状态。
所以这一步可以从大到小枚举金额，确保计算到 j 时，j-ci 还是上一层的状态。边界情况
f[0] = 0 表示凑出金额为0的最小个数是0个。
二、完全硬币找零问题（完全背包）
给定不同面额的硬币 coins 和总金额 m。每个硬币可以选择无数次。计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
状态表示f[i][j] 为考虑前 i 种硬币，凑出金额为 j 的最少数目。
状态转移考第 i 种硬币，我们可以不拿，或者拿 1...k 个，直到把金额拿爆。
f[i][j] = min(f[i-1]f[j], f[i-1][j-c]+1, f[i-1][j-2*c]+2, ..., f[i-1][j-k*c]+k)
f[0] = 0 表示金额为0时，最小硬币凑法为0
三、多重硬币找零问题（多重背包）
给定不同面额的硬币 coins 和总金额 m。每个硬币选择的次数有限制为 s。计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
状态表示这里和完全硬币问题的的初始状态表态表示很相似。考第i种硬币，我们可以不拿，或者拿1...k个，直到拿到个数的限制。
f[i][j] = min(f[i-1]f[j], f[i-1][j-c]+1, f[i-1][j-2*c]+2, ..., f[i-1][j-k*c]+k-1)所以在01问题的代码的基础上添加一层枚举硬币个数的循环即可这里可以使用二进制优化，转化为01背包问题求解。这里不扩展了。